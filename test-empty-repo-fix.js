// Test script for empty repository handling in GitHub Deployer
// This tests the fix for 409 "Git Repository is empty" errors

class EmptyRepoTestSuite {
  constructor() {
    this.testResults = [];
    this.totalTests = 0;
    this.passedTests = 0;
  }

  log(level, message) {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [${level.toUpperCase()}] ${message}`);
  }

  async runTest(testName, testFunction) {
    this.totalTests++;
    this.log('info', `Starting test: ${testName}`);
    
    try {
      const result = await testFunction();
      if (result === true || result === undefined) {
        this.passedTests++;
        this.testResults.push({ name: testName, status: 'PASS', error: null });
        this.log('success', `âœ“ ${testName} PASSED`);
      } else {
        this.testResults.push({ name: testName, status: 'FAIL', error: 'Test returned false' });
        this.log('error', `âœ— ${testName} FAILED: Test returned false`);
      }
    } catch (error) {
      this.testResults.push({ name: testName, status: 'FAIL', error: error.message });
      this.log('error', `âœ— ${testName} FAILED: ${error.message}`);
    }
  }

  // Test 1: Validate empty repository detection logic
  async testEmptyRepoDetection() {
    const errors = [
      'Failed to get branch HEAD: 409',
      'Git Repository is empty',
      '409 - "message":"Git Repository is empty","documentation_url"',
      'Reference does not exist'
    ];

    for (const errorMsg of errors) {
      const error = new Error(errorMsg);
      // Check if this is a 409 error OR a git repository empty error
      const is409Error = error.message.includes('409');
      const isEmptyRepoError = error.message.includes('Git Repository is empty') || 
                               error.message.includes('Reference does not exist');
      
      if (!is409Error && !isEmptyRepoError) {
        throw new Error(`Empty repo detection failed for: ${errorMsg}`);
      }
    }
    
    this.log('info', 'Empty repository detection logic validated');
    return true;
  }

  // Test 2: Validate initial branch creation content
  async testInitialBranchContent() {
    // Mock the createInitialBranch method logic
    const repo = 'test-repo';
    const expectedContent = `# ${repo}

Initial repository setup by Histofy Chrome Extension.

This repository will contain contribution history generated by Histofy.
Generated on: ${new Date().toISOString()}

## Purpose
This repository is used to create a custom contribution pattern on your GitHub profile.
Each commit represents activity on specific dates to create your desired contribution graph.

## How it works
- Histofy creates commits with specific dates
- Each commit follows GitHub's contribution counting rules
- All commits use your GitHub account email for proper attribution
- Contributions appear on your profile within 24 hours

Generated by Histofy Extension v1.0.0
`;

    // Validate content structure
    if (!expectedContent.includes('Initial repository setup by Histofy')) {
      throw new Error('Initial content missing Histofy reference');
    }
    
    if (!expectedContent.includes('Generated on:')) {
      throw new Error('Initial content missing timestamp');
    }

    if (!expectedContent.includes('## Purpose')) {
      throw new Error('Initial content missing purpose section');
    }

    this.log('info', 'Initial branch content structure validated');
    return true;
  }

  // Test 3: Validate GitHub Contents API payload
  async testContentsAPIPayload() {
    const fileContent = "# Test Repository\n\nTest content for validation.";
    const branchName = 'main';
    
    // Simulate the payload creation
    const payload = {
      message: 'Initial commit\n\nCreated by Histofy Chrome Extension for contribution history management',
      content: btoa(unescape(encodeURIComponent(fileContent))),
      branch: branchName
    };

    // Validate payload structure
    if (!payload.message || !payload.content || !payload.branch) {
      throw new Error('Contents API payload missing required fields');
    }

    // Validate base64 encoding
    try {
      const decoded = decodeURIComponent(escape(atob(payload.content)));
      if (decoded !== fileContent) {
        throw new Error('Base64 encoding/decoding failed');
      }
    } catch (error) {
      throw new Error(`Base64 validation failed: ${error.message}`);
    }

    this.log('info', 'GitHub Contents API payload validated');
    return true;
  }

  // Test 4: Validate fallback method structure
  async testFallbackMethodStructure() {
    // Test that fallback method would handle the required steps
    const requiredSteps = [
      'createBlob',
      'createTreeFromScratch', 
      'createInitialCommit',
      'createBranchReference'
    ];

    // Mock implementation check
    const mockDeployer = {
      createBlob: () => 'blob-sha',
      createTreeFromScratch: () => 'tree-sha',
      createInitialCommit: () => 'commit-sha'
    };

    for (const step of requiredSteps.slice(0, 3)) { // Skip last one as it's inline
      if (typeof mockDeployer[step] !== 'function') {
        throw new Error(`Fallback method missing step: ${step}`);
      }
    }

    this.log('info', 'Fallback method structure validated');
    return true;
  }

  // Test 5: Validate error handling chain
  async testErrorHandlingChain() {
    // Test the error handling sequence:
    // 1. Primary method fails with 409
    // 2. Fallback method is called
    // 3. If fallback fails, both errors are reported

    const primaryError = new Error('Failed to create initial commit: 409 - Git Repository is empty');
    const fallbackError = new Error('Failed to create branch reference: 404 - Not Found');
    
    // Simulate the error handling logic
    let finalError;
    try {
      throw primaryError;
    } catch (error) {
      try {
        throw fallbackError;
      } catch (fallbackErr) {
        finalError = new Error(`Failed to create initial branch after multiple attempts: ${error.message}, ${fallbackErr.message}`);
      }
    }

    if (!finalError.message.includes(primaryError.message) || !finalError.message.includes(fallbackError.message)) {
      throw new Error('Error handling chain not properly combining errors');
    }

    this.log('info', 'Error handling chain validated');
    return true;
  }

  // Test 6: Validate deployment flow integration
  async testDeploymentFlowIntegration() {
    // Test that the empty repo handling integrates properly with main deployment flow
    const mockErrors = [
      { code: '404', should_create_initial: true, description: 'Branch not found' },
      { code: '409', should_create_initial: true, description: 'Empty repository' },
      { code: '403', should_create_initial: false, description: 'Permission denied' },
      { code: '422', should_create_initial: false, description: 'Validation failed' }
    ];

    for (const errorCase of mockErrors) {
      const shouldHandle = errorCase.code === '404' || errorCase.code === '409';
      if (shouldHandle !== errorCase.should_create_initial) {
        throw new Error(`Incorrect handling for error ${errorCase.code}: ${errorCase.description}`);
      }
    }

    this.log('info', 'Deployment flow integration validated');
    return true;
  }

  // Run all tests
  async runAllTests() {
    this.log('info', 'ðŸš€ Starting Empty Repository Fix Test Suite');
    this.log('info', '=' * 60);

    await this.runTest('Empty Repository Detection', () => this.testEmptyRepoDetection());
    await this.runTest('Initial Branch Content', () => this.testInitialBranchContent());
    await this.runTest('Contents API Payload', () => this.testContentsAPIPayload());
    await this.runTest('Fallback Method Structure', () => this.testFallbackMethodStructure());
    await this.runTest('Error Handling Chain', () => this.testErrorHandlingChain());
    await this.runTest('Deployment Flow Integration', () => this.testDeploymentFlowIntegration());

    this.generateReport();
  }

  generateReport() {
    this.log('info', '=' * 60);
    this.log('info', 'ðŸ“Š EMPTY REPOSITORY FIX TEST RESULTS');
    this.log('info', '=' * 60);
    
    this.testResults.forEach(result => {
      const status = result.status === 'PASS' ? 'âœ“' : 'âœ—';
      const color = result.status === 'PASS' ? 'success' : 'error';
      this.log(color, `${status} ${result.name}: ${result.status}`);
      if (result.error) {
        this.log('error', `  Error: ${result.error}`);
      }
    });

    const successRate = ((this.passedTests / this.totalTests) * 100).toFixed(1);
    this.log('info', '=' * 60);
    this.log('info', `ðŸ“ˆ SUMMARY: ${this.passedTests}/${this.totalTests} tests passed (${successRate}%)`);
    
    const isProductionReady = successRate >= 95;
    if (isProductionReady) {
      this.log('success', 'ðŸŽ‰ Empty repository fix is PRODUCTION READY!');
    } else if (successRate >= 80) {
      this.log('warning', 'âš ï¸  Empty repository fix needs minor improvements');
    } else {
      this.log('error', 'âŒ Empty repository fix requires significant fixes');
    }

    return {
      totalTests: this.totalTests,
      passedTests: this.passedTests,
      successRate: parseFloat(successRate),
      isProductionReady
    };
  }
}

// Run the test suite
async function runEmptyRepoTests() {
  const testSuite = new EmptyRepoTestSuite();
  return await testSuite.runAllTests();
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { EmptyRepoTestSuite, runEmptyRepoTests };
} else if (typeof window !== 'undefined') {
  window.EmptyRepoTestSuite = EmptyRepoTestSuite;
  window.runEmptyRepoTests = runEmptyRepoTests;
}

// Auto-run if this script is executed directly
if (typeof require !== 'undefined' && require.main === module) {
  runEmptyRepoTests().then(result => {
    process.exit(result && result.isProductionReady ? 0 : 1);
  }).catch(error => {
    console.error('Test suite failed:', error);
    process.exit(1);
  });
}
